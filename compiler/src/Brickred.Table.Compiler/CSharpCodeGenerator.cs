using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace Brickred.Table.Compiler
{
    using ColumnType = TableDescriptor.TableDef.ColumnType;
    using FieldType = TableDescriptor.StructDef.FieldType;
    using TableKeyType = TableDescriptor.TableDef.KeyType;

    public sealed class CSharpCodeGenerator : BaseCodeGenerator
    {
        private TableDescriptor descriptor = null;
        private string reader = "";
        private string newLineStr = "";

        public CSharpCodeGenerator()
        {
        }

        public override void Dispose()
        {
            this.newLineStr = "";

            this.reader = "";
            if (this.descriptor != null) {
                this.descriptor = null;
            }
        }

        public override bool Generate(
            TableDescriptor descriptor, string reader,
            string outputDir, NewLineType newLineType)
        {
            this.descriptor = descriptor;
            this.reader = reader;

            if (newLineType == NewLineType.Dos) {
                this.newLineStr = "\r\n";
            } else {
                this.newLineStr = "\n";
            }

            for (int i = 0; i < this.descriptor.GlobalStructs.Count; ++i) {
                TableDescriptor.StructDef def =
                    this.descriptor.GlobalStructs[i];

                string filePath = Path.Combine(
                    outputDir, def.Name + ".cs");
                string fileContent = GenerateGlobalStructFile(def);
                try {
                    File.WriteAllText(filePath, fileContent);
                } catch (Exception e) {
                    Console.Error.WriteLine(string.Format(
                        "error: write file {0} failed: {1}",
                        filePath, e.Message));
                    return false;
                }
            }

            for (int i = 0; i < this.descriptor.Tables.Count; ++i) {
                TableDescriptor.TableDef def = this.descriptor.Tables[i];

                string filePath = Path.Combine(
                    outputDir, def.Name + ".cs");
                string fileContent = GenerateTableFile(def);
                try {
                    File.WriteAllText(filePath, fileContent);
                } catch (Exception e) {
                    Console.Error.WriteLine(string.Format(
                        "error: write file {0} failed: {1}",
                        filePath, e.Message));
                    return false;
                }
            }

            return true;
        }

        private string GenerateGlobalStructFile(
            TableDescriptor.StructDef structDef)
        {
            string dontEditComment;
            string namespaceDeclStart;
            string namespaceDeclEnd;
            string structDecl;
            string indent = "";

            GetDontEditComment(
                out dontEditComment);
            GetNamespaceDecl(
                out namespaceDeclStart, out namespaceDeclEnd);

            if (namespaceDeclStart != "") {
                indent += "    ";
            }

            GetStructDecl(structDef, indent,
                out structDecl);

            StringBuilder sb = new StringBuilder();
            sb.Append(dontEditComment);
            sb.Append(this.newLineStr);
            sb.Append(namespaceDeclStart);
            sb.Append(structDecl);
            sb.Append(namespaceDeclEnd);

            return sb.ToString();
        }

        private string GenerateTableFile(
            TableDescriptor.TableDef tableDef)
        {
            string dontEditComment;
            string namespaceDeclStart;
            string namespaceDeclEnd;
            string tableDecl;
            string indent = "";

            GetDontEditComment(
                out dontEditComment);
            GetNamespaceDecl(
                out namespaceDeclStart, out namespaceDeclEnd);

            if (namespaceDeclStart != "") {
                indent += "    ";
            }

            GetTableDecl(tableDef, indent,
                out tableDecl);

            StringBuilder sb = new StringBuilder();
            sb.Append(dontEditComment);
            sb.Append(this.newLineStr);
            sb.Append(namespaceDeclStart);
            sb.Append(tableDecl);
            sb.Append(namespaceDeclEnd);

            return sb.ToString();
        }

        private void GetDontEditComment(out string output)
        {
            output = string.Format(
                "/*{0}" +
                " * Generated by brickred table compiler.{0}" +
                " * Do not edit unless you are sure that you know what you are doing.{0}" +
                " */{0}",
                this.newLineStr);
        }

        private string GetCSharpType(
            TableDescriptor.StructDef.FieldDef fieldDef)
        {
            string csharpType = "";
            if (fieldDef.Type == FieldType.Int) {
                csharpType = "int";
            } else if (fieldDef.Type == FieldType.String) {
                csharpType = "string";
            }

            return csharpType;
        }

        private string GetCSharpType(
            TableDescriptor.TableDef.ColumnDef columnDef)
        {
            ColumnType checkType;
            if (columnDef.Type == ColumnType.List) {
                checkType = columnDef.ListType;
            } else {
                checkType = columnDef.Type;
            }

            string csharpType = "";
            if (checkType == ColumnType.Int) {
                csharpType = "int";
            } else if (checkType == ColumnType.String) {
                csharpType = "string";
            } else if (checkType == ColumnType.Struct) {
                csharpType = columnDef.RefStructDef.Name;
            }

            if (columnDef.Type == ColumnType.List) {
                return string.Format("System.Collections.Generic.List<{0}>",
                    csharpType);
            } else {
                return csharpType;
            }
        }

        private string GetCSharpTypeDefaultValue(
            TableDescriptor.StructDef.FieldDef fieldDef)
        {
            string defaultValue = "";
            if (fieldDef.Type == FieldType.Int) {
                defaultValue = "0";
            } else if (fieldDef.Type == FieldType.String) {
                defaultValue = "\"\"";
            }

            return defaultValue;
        }

        private string GetCSharpTypeDefaultValue(
            TableDescriptor.TableDef.ColumnDef columnDef)
        {
            string defaultValue = "";
            if (columnDef.Type == ColumnType.Int) {
                defaultValue = "0";
            } else if (columnDef.Type == ColumnType.String) {
                defaultValue = "\"\"";
            } else if (columnDef.Type == ColumnType.Struct ||
                       columnDef.Type == ColumnType.List) {
                defaultValue = string.Format("new {0}()",
                    GetCSharpType(columnDef));
            }

            return defaultValue;
        }

        private void GetNamespaceDecl(
            out string start, out string end)
        {
            start = "";
            end = "";

            TableDescriptor.ReaderDef readerDef = null;
            if (this.descriptor.Readers.TryGetValue(
                    this.reader, out readerDef) == false) {
                return;
            }
            if (readerDef.Namespace == "") {
                return;
            }

            start = string.Format(
                "namespace {0}{1}" +
                "{{{1}",
                readerDef.Namespace, this.newLineStr);
            end = string.Format(
                "}}{0}", this.newLineStr);
        }

        private void GetStructDecl(
            TableDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public sealed class {1} : Brickred.Table.BaseStruct{2}" +
                "{0}{{{2}",
                indent, structDef.Name, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);
            string fieldDecl;
            string parseFuncDecl;

            indent += "    ";
            GetStructDeclFieldDecl(
                structDef, indent, out fieldDecl);
            GetStructDeclParseFunc(
                structDef, indent, out parseFuncDecl);

            sb.Append(start);
            if (fieldDecl != "") {
                sb.Append(fieldDecl);
                sb.Append(this.newLineStr);
            }
            sb.Append(parseFuncDecl);
            sb.Append(end);

            output = sb.ToString();
        }

        private void GetStructDeclFieldDecl(
            TableDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < structDef.Fields.Count; ++i) {
                TableDescriptor.StructDef.FieldDef fieldDef =
                    structDef.Fields[i];

                string csharpType = GetCSharpType(fieldDef);
                string defaultValue = GetCSharpTypeDefaultValue(fieldDef);
                sb.AppendFormat("{0}public {1} {2} = {3};{4}",
                    indent, csharpType, fieldDef.Name, defaultValue,
                    this.newLineStr);
            }

            output = sb.ToString();
        }

        private void GetStructDeclParseFunc(
            TableDescriptor.StructDef structDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public override bool Parse(string text){1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";

            if (structDef.Fields.Count == 0) {
                sb.AppendFormat(
                    "{0}return true;{1}",
                    indent, this.newLineStr);
            } else {
                sb.AppendFormat(
                    "{0}Brickred.Table.ColumnSpliter s ={1}"+
                    "{0}    new Brickred.Table.ColumnSpliter(text, ';');{1}" +
                    "{1}",
                    indent, this.newLineStr);

                for (int i = 0; i < structDef.Fields.Count; ++i) {
                    TableDescriptor.StructDef.FieldDef fieldDef =
                        structDef.Fields[i];

                    if (fieldDef.Type == FieldType.Int) {
                        sb.AppendFormat(
                            "{0}if (s.NextInt(ref this.{1}) == false) {{{2}" +
                            "{0}    return false;{2}" +
                            "{0}}}{2}",
                            indent, fieldDef.Name, this.newLineStr);
                    } else if (fieldDef.Type == FieldType.String) {
                        sb.AppendFormat(
                            "{0}if (s.NextString(ref this.{1}) == false) {{{2}" +
                            "{0}    return false;{2}" +
                            "{0}}}{2}",
                            indent, fieldDef.Name, this.newLineStr);
                    }
                }

                sb.AppendFormat(
                    "{0}if (s.NextString()) {{{1}" +
                    "{0}    return false;{1}" +
                    "{0}}}{1}" +
                    "{1}" +
                    "{0}return true;{1}",
                    indent, this.newLineStr);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetTableDecl(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public sealed class {1}{2}" +
                "{0}{{{2}",
                indent, tableDef.Name, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);
            string rowClassDecl;
            string memberDecl;
            string parseFuncDecl;
            string getRowFuncDecl = "";

            indent += "    ";
            GetTableDeclRowClassDecl(
                tableDef, indent, out rowClassDecl);
            GetTableDeclMemberDecl(
                tableDef, indent, out memberDecl);
            GetTableDeclParseFunc(
                tableDef, indent, out parseFuncDecl);

            if (tableDef.TableKeyType == TableKeyType.SingleKey) {
                GetTableDeclGetRowFunc(
                    tableDef, indent, out getRowFuncDecl);
            } else if (tableDef.TableKeyType == TableKeyType.SetKey) {
                GetTableDeclGetRowSetFunc(
                    tableDef, indent, out getRowFuncDecl);
            }

            sb.Append(start);

            for (int i = 0; i < tableDef.LocalStructs.Count; ++i) {
                string decl;
                GetStructDecl(tableDef.LocalStructs[i],
                    indent, out decl);
                sb.Append(decl);
                sb.Append(this.newLineStr);
            }

            if (rowClassDecl != "") {
                sb.Append(rowClassDecl);
                sb.Append(this.newLineStr);
            }
            sb.Append(memberDecl);
            sb.Append(this.newLineStr);
            sb.Append(parseFuncDecl);
            sb.Append(this.newLineStr);
            sb.Append(getRowFuncDecl);

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetTableDeclRowClassDecl(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public sealed class Row{1}" +
                "{0}{{{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}",
                indent, this.newLineStr);

            indent += "    ";

            sb.Append(start);

            for (int i = 0; i < tableDef.Columns.Count; ++i) {
                TableDescriptor.TableDef.ColumnDef columnDef =
                    tableDef.Columns[i];

                string csharpType = GetCSharpType(columnDef);
                string defaultValue = GetCSharpTypeDefaultValue(columnDef);
                if (defaultValue.Length > 10) {
                    sb.AppendFormat(
                        "{0}public {1} {2} ={4}" +
                        "{0}    {3};{4}",
                        indent, csharpType, columnDef.Name, defaultValue,
                        this.newLineStr);
                } else {
                    sb.AppendFormat("{0}public {1} {2} = {3};{4}",
                        indent, csharpType, columnDef.Name, defaultValue,
                        this.newLineStr);
                }
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetTableDeclMemberDecl(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            if (tableDef.TableKeyType == TableKeyType.SingleKey) {
                sb.AppendFormat(
                    "{0}public System.Collections.Generic.SortedDictionary" +
                    "<{1}, Row> rows ={2}" +
                    "{0}    new System.Collections.Generic.SortedDictionary" +
                    "<{1}, Row>();{2}" +
                    "{0}public System.Collections.Generic.SortedDictionary" +
                    "<{1}, Row> Rows{2}" +
                    "{0}{{{2}" +
                    "{0}    get {{ return this.rows; }}{2}" +
                    "{0}}}{2}",
                    indent, GetCSharpType(tableDef.TableKey), this.newLineStr);
            } else if (tableDef.TableKeyType == TableKeyType.SetKey) {
                sb.AppendFormat(
                    "{0}public System.Collections.Generic.SortedDictionary<{2}" +
                    "{0}    {1}, System.Collections.Generic.List<Row>> rowSets ={2}" +
                    "{0}        new System.Collections.Generic.SortedDictionary<{2}" +
                    "{0}            {1}, System.Collections.Generic.List<Row>>();{2}" +
                    "{0}public System.Collections.Generic.SortedDictionary<{2}" +
                    "{0}    {1}, System.Collections.Generic.List<Row>> RowSets{2}" +
                    "{0}{{{2}" +
                    "{0}    get {{ return this.rowSets; }}{2}" +
                    "{0}}}{2}",
                    indent, GetCSharpType(tableDef.TableKey), this.newLineStr);
            }

            output = sb.ToString();
        }

        private void GetTableDeclParseFunc(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}public bool Parse(string text, out string errorInfo){1}" +
                "{0}{{{1}" +
                "{0}    Brickred.Table.LineReader r = " +
                "new Brickred.Table.LineReader(text);{1}" +
                "{0}    System.Collections.Generic.List<string> lineBuffer = " +
                "null;{1}" +
                "{0}    int columnCountReq = {2};{1}" +
                "{1}",
                indent, this.newLineStr, tableDef.Columns.Count);
            string end = string.Format(
                "{0}    errorInfo = \"\";{1}" +
                "{0}    return true;{1}" +
                "{0}}}{1}",
                indent, this.newLineStr);

            string readCommentLine;
            string readNameLine;
            string readDataLine = "";

            indent += "    ";
            GetTableDeclParseFuncReadCommentLine(
                tableDef, indent, out readCommentLine);
            GetTableDeclParseFuncReadNameLine(
                tableDef, indent, out readNameLine);

            if (tableDef.TableKeyType == TableKeyType.SingleKey) {
                GetTableDeclParseFuncSingleKeyReadDataLine(
                    tableDef, indent, out readDataLine);
            } else if (tableDef.TableKeyType == TableKeyType.SetKey) {
                GetTableDeclParseFuncSetKeyReadDataLine(
                    tableDef, indent, out readDataLine);
            }

            sb.Append(start);
            sb.Append(readCommentLine);
            sb.Append(readNameLine);
            sb.Append(readDataLine);
            sb.Append(end);

            output = sb.ToString();
        }

        private void GetTableDeclParseFuncReadCommentLine(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            output = string.Format(
                "{0}// read comment line{1}" +
                "{0}lineBuffer = r.NextLine();{1}" +
                "{0}if (lineBuffer == null) {{{1}" +
                "{0}    errorInfo = \"comment line is required\";{1}" +
                "{0}    return false;{1}" +
                "{0}}}{1}" +
                "{0}if (lineBuffer.Count != columnCountReq) {{{1}" +
                "{0}    errorInfo = string.Format({1}" +
                "{0}        \"comment line column count {{0}} is invalid," +
                " should be {{1}}\",{1}" +
                "{0}         lineBuffer.Count, columnCountReq);{1}" +
                "{0}    return false;{1}" +
                "{0}}}{1}" +
                "{1}",
                indent, this.newLineStr);
        }

        private void GetTableDeclParseFuncReadNameLine(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            string start = string.Format(
                "{0}// read name line{1}" +
                "{0}lineBuffer = r.NextLine();{1}" +
                "{0}if (lineBuffer == null) {{{1}" +
                "{0}    errorInfo = \"name line is required\";{1}" +
                "{0}    return false;{1}" +
                "{0}}}{1}" +
                "{0}if (lineBuffer.Count != columnCountReq) {{{1}" +
                "{0}    errorInfo = string.Format({1}" +
                "{0}        \"name line column count {{0}} is invalid," +
                " should be {{1}}\",{1}" +
                "{0}         lineBuffer.Count, columnCountReq);{1}" +
                "{0}    return false;{1}" +
                "{0}}}{1}" +
                "{0}{{{1}" +
                "{0}    int colNumber = 0;{1}" +
                "{1}",
                indent, this.newLineStr);
            string end = string.Format(
                "{0}}}{1}" +
                "{1}",
                indent, this.newLineStr);

            sb.Append(start);

            indent += "    ";
            for (int i = 0; i < tableDef.Columns.Count; ++i) {
                TableDescriptor.TableDef.ColumnDef columnDef =
                    tableDef.Columns[i];

                sb.AppendFormat(
                    "{0}if (lineBuffer[colNumber++] != \"{1}\") {{{2}" +
                    "{0}    errorInfo = string.Format({2}" +
                    "{0}        \"column {{0}} should be named as `{1}`\"," +
                    " colNumber);{2}" +
                    "{0}    return false;{2}" +
                    "{0}}}{2}",
                    indent, columnDef.Name, this.newLineStr);
            }

            sb.Append(end);

            output = sb.ToString();
        }

        private void GetTableDeclParseFuncSingleKeyReadDataLine(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            string parseColumns;
            GetTableDeclParseFuncParseColumns(
                tableDef, indent + "    ", out parseColumns);

            output = string.Format(
                "{0}// read data lines{1}" +
                "{0}int lineNumber = 3;{1}" +
                "{0}this.rows.Clear();{1}" +
                "{0}for (;;) {{{1}" +
                "{0}    lineBuffer = r.NextLine();{1}" +
                "{0}    if (lineBuffer == null) {{{1}" +
                "{0}        break;{1}" +
                "{0}    }}{1}" +
                "{0}    if (lineBuffer.Count != columnCountReq) {{{1}" +
                "{0}        errorInfo = string.Format({1}" +
                "{0}            \"line {{0}} column count {{1}} is invalid, " +
                "should be {{2}}\",{1}" +
                "{0}            lineNumber, lineBuffer.Count, " +
                "columnCountReq);{1}" +
                "{0}        return false;{1}" +
                "{0}    }}{1}" +
                "{0}    if (lineBuffer[{2}].Length == 0) {{{1}" +
                "{0}        errorInfo = string.Format({1}" +
                "{0}            \"line {{0}} key `{3}` is empty\", " +
                "lineNumber);{1}" +
                "{0}        return false;{1}" +
                "{0}    }}{1}" +
                "{1}" +
                "{0}    Row row = new Row();{1}" +
                "{0}    int colNumber = 0;{1}" +
                "{1}" +
                "{4}" +
                "{1}" +
                "{0}    if (GetRow(row.{3}) != null) {{{1}" +
                "{0}        errorInfo = string.Format({1}" +
                "{0}            \"line {{0}} key `{3}` value {{1}} is duplicated\", " +
                "lineNumber, row.{3});{1}" +
                "{0}        return false;{1}" +
                "{0}    }}{1}" +
                "{1}" +
                "{0}    this.rows.Add(row.{3}, row);{1}" +
                "{1}" +
                "{0}    lineNumber += 1;{1}" +
                "{0}}}{1}" +
                "{1}",
                indent, this.newLineStr,
                tableDef.TableKeyColumnIndex, tableDef.TableKey.Name,
                parseColumns);
        }

        private void GetTableDeclParseFuncSetKeyReadDataLine(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            string parseColumns;
            GetTableDeclParseFuncParseColumns(
                tableDef, indent + "    ", out parseColumns);

            string keyDefine = "";
            if (tableDef.TableKey.Type == ColumnType.Int) {
                keyDefine = "int key = Brickred.Table.Util.Atoi(keyStr)";
            } else if (tableDef.TableKey.Type == ColumnType.String) {
                keyDefine = "string key = keyStr";
            }

            output = string.Format(
                "{0}// read data lines{1}" +
                "{0}int lineNumber = 3;{1}" +
                "{0}string lastKey = \"\";{1}" +
                "{0}this.rowSets.Clear();{1}" +
                "{0}for (;;) {{{1}" +
                "{0}    lineBuffer = r.NextLine();{1}" +
                "{0}    if (lineBuffer == null) {{{1}" +
                "{0}        break;{1}" +
                "{0}    }}{1}" +
                "{0}    if (lineBuffer.Count != columnCountReq) {{{1}" +
                "{0}        errorInfo = string.Format({1}" +
                "{0}            \"line {{0}} column count {{1}} is invalid, " +
                "should be {{2}}\",{1}" +
                "{0}            lineNumber, lineBuffer.Count, " +
                "columnCountReq);{1}" +
                "{0}        return false;{1}" +
                "{0}    }}{1}" +
                "{1}" +
                "{0}    string keyStr = lineBuffer[{2}];{1}" +
                "{0}    if (keyStr.Length == 0) {{{1}" +
                "{0}        if (lastKey.Length > 0) {{{1}" +
                "{0}            keyStr = lastKey;{1}" +
                "{0}        }} else {{{1}" +
                "{0}            errorInfo = string.Format({1}" +
                "{0}                \"line {{0}} key `{3}` is empty\", " +
                "lineNumber);{1}" +
                "{0}            return false;{1}" +
                "{0}        }}{1}" +
                "{0}    }}{1}" +
                "{1}" +
                "{0}    Row row = new Row();{1}" +
                "{0}    int colNumber = 0;{1}" +
                "{1}" +
                "{4}" +
                "{1}" +
                "{0}    {5};{1}" +
                "{0}    if (keyStr != lastKey) {{{1}" +
                "{0}        if (GetRowSet(key) != null) {{{1}" +
                "{0}            errorInfo = string.Format({1}" +
                "{0}                \"line {{0}} key `{3}` value {{1}} is duplicated\",{1} " +
                "{0}                lineNumber, row.{3});{1}" +
                "{0}            return false;{1}" +
                "{0}        }}{1}" +
                "{0}        System.Collections.Generic.List<Row> rowSet ={1}" +
                "{0}            new System.Collections.Generic.List<Row>();{1}" +
                "{0}        rowSet.Add(row);{1}" +
                "{0}        this.rowSets.Add(key, rowSet);{1}" +
                "{0}        lastKey = keyStr;{1}" +
                "{0}    }} else {{{1}" +
                "{0}        row.{3} = key;{1}" +
                "{0}        this.rowSets[key].Add(row);{1}" +
                "{0}    }}{1}" +
                "{1}" +
                "{0}    lineNumber += 1;{1}" +
                "{0}}}{1}" +
                "{1}",
                indent, this.newLineStr,
                tableDef.TableKeyColumnIndex, tableDef.TableKey.Name,
                parseColumns, keyDefine);
        }

        private void GetTableDeclParseFuncParseColumns(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < tableDef.Columns.Count; ++i) {
                TableDescriptor.TableDef.ColumnDef columnDef =
                    tableDef.Columns[i];

                ColumnType checkType;
                if (columnDef.Type == ColumnType.List) {
                    checkType = columnDef.ListType;
                } else {
                    checkType = columnDef.Type;
                }
                bool isList = (columnDef.Type == ColumnType.List);

                if (checkType == ColumnType.Int) {
                    if (isList) {
                        sb.AppendFormat(
                            "{0}Brickred.Table.Util.ReadColumnIntList(" +
                            "lineBuffer[colNumber++], ref row.{1});{2}",
                            indent, columnDef.Name, this.newLineStr);
                    } else {
                        sb.AppendFormat(
                            "{0}row.{1} = Brickred.Table.Util.Atoi(" +
                            "lineBuffer[colNumber++]);{2}",
                            indent, columnDef.Name, this.newLineStr);
                    }
                } else if (checkType == ColumnType.String) {
                    if (isList) {
                        sb.AppendFormat(
                            "{0}Brickred.Table.Util.ReadColumnStringList(" +
                            "lineBuffer[colNumber++], ref row.{1});{2}",
                            indent, columnDef.Name, this.newLineStr);
                    } else {
                        sb.AppendFormat(
                            "{0}row.{1} = lineBuffer[colNumber++];{2}",
                            indent, columnDef.Name, this.newLineStr);
                    }
                } else if (checkType == ColumnType.Struct) {
                    if (isList) {
                        sb.AppendFormat(
                            "{0}if (Brickred.Table.Util.ReadColumnStructList({1}" +
                            "{0}        lineBuffer[colNumber++], ref row.{2}) " +
                            "== false) {{{1}" +
                            "{0}    errorInfo = string.Format({1}" +
                            "{0}        \"line {{0}} column `{2}` value is invalid\", " +
                            "lineNumber);{1}" +
                            "{0}    return false;{1}" +
                            "{0}}}{1}",
                            indent, this.newLineStr, columnDef.Name);
                    } else {
                        sb.AppendFormat(
                            "{0}if (row.{1}.Parse(" +
                            "lineBuffer[colNumber++]) == false) {{{2}" +
                            "{0}    errorInfo = string.Format({2}" +
                            "{0}        \"line {{0}} column `{1}` value is invalid\", " +
                            "lineNumber);{2}" +
                            "{0}    return false;{2}" +
                            "{0}}}{2}",
                            indent, columnDef.Name, this.newLineStr);
                    }
                }
            }

            output = sb.ToString();
        }

        private void GetTableDeclGetRowFunc(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            output = string.Format(
                "{0}public Row GetRow({1} key){2}" +
                "{0}{{{2}" +
                "{0}    Row row = null;{2}" +
                "{0}    if (this.rows.TryGetValue(key, out row) == false) {{{2}" +
                "{0}        return null;{2}" +
                "{0}    }}{2}" +
                "{2}" +
                "{0}    return row;{2}" +
                "{0}}}{2}",
                indent, GetCSharpType(tableDef.TableKey), this.newLineStr);
        }

        private void GetTableDeclGetRowSetFunc(
            TableDescriptor.TableDef tableDef,
            string indent, out string output)
        {
            output = string.Format(
                "{0}public System.Collections.Generic.List<Row> GetRowSet({1} key){2}" +
                "{0}{{{2}" +
                "{0}    System.Collections.Generic.List<Row> rowSet = null;{2}" +
                "{0}    if (this.rowSets.TryGetValue(key, out rowSet) == false) {{{2}" +
                "{0}        return null;{2}" +
                "{0}    }}{2}" +
                "{2}" +
                "{0}    return rowSet;{2}" +
                "{0}}}{2}",
                indent, GetCSharpType(tableDef.TableKey), this.newLineStr);
        }
    }
}
